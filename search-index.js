var searchIndex={};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and…","i":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"BE","","A type alias for [`BigEndian`].",null,null],[6,"LE","","A type alias for [`LittleEndian`].",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends [`Read`] with methods for reading numbers. (For…",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,[[["self"]],[["result",["u8"]],["u8"]]]],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,[[["self"]],[["i8"],["result",["i8"]]]]],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,[[["self"]],[["u16"],["result",["u16"]]]]],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,[[["self"]],[["result",["i16"]],["i16"]]]],[11,"read_u24","","Reads an unsigned 24 bit integer from the underlying reader.",0,[[["self"]],[["result",["u32"]],["u32"]]]],[11,"read_i24","","Reads a signed 24 bit integer from the underlying reader.",0,[[["self"]],[["i32"],["result",["i32"]]]]],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,[[["self"]],[["result",["u32"]],["u32"]]]],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,[[["self"]],[["i32"],["result",["i32"]]]]],[11,"read_u48","","Reads an unsigned 48 bit integer from the underlying reader.",0,[[["self"]],[["u64"],["result",["u64"]]]]],[11,"read_i48","","Reads a signed 48 bit integer from the underlying reader.",0,[[["self"]],[["i64"],["result",["i64"]]]]],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,[[["self"]],[["u64"],["result",["u64"]]]]],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,[[["self"]],[["i64"],["result",["i64"]]]]],[11,"read_u128","","Reads an unsigned 128 bit integer from the underlying…",0,[[["self"]],[["u128"],["result",["u128"]]]]],[11,"read_i128","","Reads a signed 128 bit integer from the underlying reader.",0,[[["self"]],[["i128"],["result",["i128"]]]]],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying…",0,[[["self"],["usize"]],[["u64"],["result",["u64"]]]]],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,[[["self"],["usize"]],[["i64"],["result",["i64"]]]]],[11,"read_uint128","","Reads an unsigned n-bytes integer from the underlying…",0,[[["self"],["usize"]],[["u128"],["result",["u128"]]]]],[11,"read_int128","","Reads a signed n-bytes integer from the underlying reader.",0,[[["self"],["usize"]],[["i128"],["result",["i128"]]]]],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point…",0,[[["self"]],[["f32"],["result",["f32"]]]]],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point…",0,[[["self"]],[["result",["f64"]],["f64"]]]],[11,"read_u16_into","","Reads a sequence of unsigned 16 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_u32_into","","Reads a sequence of unsigned 32 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_u64_into","","Reads a sequence of unsigned 64 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_u128_into","","Reads a sequence of unsigned 128 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i8_into","","Reads a sequence of signed 8 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i16_into","","Reads a sequence of signed 16 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i32_into","","Reads a sequence of signed 32 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i64_into","","Reads a sequence of signed 64 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i128_into","","Reads a sequence of signed 128 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_f32_into","","Reads a sequence of IEEE754 single-precision (4 bytes)…",0,[[["self"]],["result"]]],[11,"read_f32_into_unchecked","","DEPRECATED.",0,[[["self"]],["result"]]],[11,"read_f64_into","","Reads a sequence of IEEE754 double-precision (8 bytes)…",0,[[["self"]],["result"]]],[11,"read_f64_into_unchecked","","DEPRECATED.",0,[[["self"]],["result"]]],[8,"WriteBytesExt","","Extends [`Write`] with methods for writing numbers. (For…",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,[[["self"],["u8"]],["result"]]],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,[[["self"],["i8"]],["result"]]],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,[[["u16"],["self"]],["result"]]],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,[[["self"],["i16"]],["result"]]],[11,"write_u24","","Writes an unsigned 24 bit integer to the underlying writer.",1,[[["self"],["u32"]],["result"]]],[11,"write_i24","","Writes a signed 24 bit integer to the underlying writer.",1,[[["self"],["i32"]],["result"]]],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,[[["self"],["u32"]],["result"]]],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,[[["self"],["i32"]],["result"]]],[11,"write_u48","","Writes an unsigned 48 bit integer to the underlying writer.",1,[[["self"],["u64"]],["result"]]],[11,"write_i48","","Writes a signed 48 bit integer to the underlying writer.",1,[[["i64"],["self"]],["result"]]],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,[[["self"],["u64"]],["result"]]],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,[[["i64"],["self"]],["result"]]],[11,"write_u128","","Writes an unsigned 128 bit integer to the underlying writer.",1,[[["self"],["u128"]],["result"]]],[11,"write_i128","","Writes a signed 128 bit integer to the underlying writer.",1,[[["self"],["i128"]],["result"]]],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,[[["self"],["u64"],["usize"]],["result"]]],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,[[["i64"],["self"],["usize"]],["result"]]],[11,"write_uint128","","Writes an unsigned n-bytes integer to the underlying writer.",1,[[["self"],["usize"],["u128"]],["result"]]],[11,"write_int128","","Writes a signed n-bytes integer to the underlying writer.",1,[[["self"],["i128"],["usize"]],["result"]]],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point…",1,[[["f32"],["self"]],["result"]]],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point…",1,[[["self"],["f64"]],["result"]]],[8,"ByteOrder","","`ByteOrder` describes types that can serialize integers as…",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,[[],["u16"]]],[11,"read_u24","","Reads an unsigned 24 bit integer from `buf`, stored in u32.",2,[[],["u32"]]],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,[[],["u32"]]],[11,"read_u48","","Reads an unsigned 48 bit integer from `buf`, stored in u64.",2,[[],["u64"]]],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,[[],["u64"]]],[10,"read_u128","","Reads an unsigned 128 bit integer from `buf`.",2,[[],["u128"]]],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,[[["usize"]],["u64"]]],[10,"read_uint128","","Reads an unsigned n-bytes integer from `buf`.",2,[[["usize"]],["u128"]]],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,[[["u16"]]]],[11,"write_u24","","Writes an unsigned 24 bit integer `n` to `buf`, stored in…",2,[[["u32"]]]],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,[[["u32"]]]],[11,"write_u48","","Writes an unsigned 48 bit integer `n` to `buf`, stored in…",2,[[["u64"]]]],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,[[["u64"]]]],[10,"write_u128","","Writes an unsigned 128 bit integer `n` to `buf`.",2,[[["u128"]]]],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,[[["usize"],["u64"]]]],[10,"write_uint128","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,[[["usize"],["u128"]]]],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,[[],["i16"]]],[11,"read_i24","","Reads a signed 24 bit integer from `buf`, stored in i32.",2,[[],["i32"]]],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,[[],["i32"]]],[11,"read_i48","","Reads a signed 48 bit integer from `buf`, stored in i64.",2,[[],["i64"]]],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,[[],["i64"]]],[11,"read_i128","","Reads a signed 128 bit integer from `buf`.",2,[[],["i128"]]],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,[[["usize"]],["i64"]]],[11,"read_int128","","Reads a signed n-bytes integer from `buf`.",2,[[["usize"]],["i128"]]],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point…",2,[[],["f32"]]],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point…",2,[[],["f64"]]],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,[[["i16"]]]],[11,"write_i24","","Writes a signed 24 bit integer `n` to `buf`, stored in i32.",2,[[["i32"]]]],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,[[["i32"]]]],[11,"write_i48","","Writes a signed 48 bit integer `n` to `buf`, stored in i64.",2,[[["i64"]]]],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,[[["i64"]]]],[11,"write_i128","","Writes a signed 128 bit integer `n` to `buf`.",2,[[["i128"]]]],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,[[["i64"],["usize"]]]],[11,"write_int128","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,[[["i128"],["usize"]]]],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point…",2,[[["f32"]]]],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point…",2,[[["f64"]]]],[10,"read_u16_into","","Reads unsigned 16 bit integers from `src` into `dst`.",2,[[]]],[10,"read_u32_into","","Reads unsigned 32 bit integers from `src` into `dst`.",2,[[]]],[10,"read_u64_into","","Reads unsigned 64 bit integers from `src` into `dst`.",2,[[]]],[10,"read_u128_into","","Reads unsigned 128 bit integers from `src` into `dst`.",2,[[]]],[11,"read_i16_into","","Reads signed 16 bit integers from `src` to `dst`.",2,[[]]],[11,"read_i32_into","","Reads signed 32 bit integers from `src` into `dst`.",2,[[]]],[11,"read_i64_into","","Reads signed 64 bit integers from `src` into `dst`.",2,[[]]],[11,"read_i128_into","","Reads signed 128 bit integers from `src` into `dst`.",2,[[]]],[11,"read_f32_into","","Reads IEEE754 single-precision (4 bytes) floating point…",2,[[]]],[11,"read_f32_into_unchecked","","DEPRECATED.",2,[[]]],[11,"read_f64_into","","Reads IEEE754 single-precision (4 bytes) floating point…",2,[[]]],[11,"read_f64_into_unchecked","","DEPRECATED.",2,[[]]],[10,"write_u16_into","","Writes unsigned 16 bit integers from `src` into `dst`.",2,[[]]],[10,"write_u32_into","","Writes unsigned 32 bit integers from `src` into `dst`.",2,[[]]],[10,"write_u64_into","","Writes unsigned 64 bit integers from `src` into `dst`.",2,[[]]],[10,"write_u128_into","","Writes unsigned 128 bit integers from `src` into `dst`.",2,[[]]],[11,"write_i8_into","","Writes signed 8 bit integers from `src` into `dst`.",2,[[]]],[11,"write_i16_into","","Writes signed 16 bit integers from `src` into `dst`.",2,[[]]],[11,"write_i32_into","","Writes signed 32 bit integers from `src` into `dst`.",2,[[]]],[11,"write_i64_into","","Writes signed 64 bit integers from `src` into `dst`.",2,[[]]],[11,"write_i128_into","","Writes signed 128 bit integers from `src` into `dst`.",2,[[]]],[11,"write_f32_into","","Writes IEEE754 single-precision (4 bytes) floating point…",2,[[]]],[11,"write_f64_into","","Writes IEEE754 double-precision (8 bytes) floating point…",2,[[]]],[10,"from_slice_u16","","Converts the given slice of unsigned 16 bit integers to a…",2,[[]]],[10,"from_slice_u32","","Converts the given slice of unsigned 32 bit integers to a…",2,[[]]],[10,"from_slice_u64","","Converts the given slice of unsigned 64 bit integers to a…",2,[[]]],[10,"from_slice_u128","","Converts the given slice of unsigned 128 bit integers to a…",2,[[]]],[11,"from_slice_i16","","Converts the given slice of signed 16 bit integers to a…",2,[[]]],[11,"from_slice_i32","","Converts the given slice of signed 32 bit integers to a…",2,[[]]],[11,"from_slice_i64","","Converts the given slice of signed 64 bit integers to a…",2,[[]]],[11,"from_slice_i128","","Converts the given slice of signed 128 bit integers to a…",2,[[]]],[10,"from_slice_f32","","Converts the given slice of IEEE754 single-precision (4…",2,[[]]],[10,"from_slice_f64","","Converts the given slice of IEEE754 double-precision (8…",2,[[]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"read_u16","","",3,[[],["u16"]]],[11,"read_u32","","",3,[[],["u32"]]],[11,"read_u64","","",3,[[],["u64"]]],[11,"read_u128","","",3,[[],["u128"]]],[11,"read_uint","","",3,[[["usize"]],["u64"]]],[11,"read_uint128","","",3,[[["usize"]],["u128"]]],[11,"write_u16","","",3,[[["u16"]]]],[11,"write_u32","","",3,[[["u32"]]]],[11,"write_u64","","",3,[[["u64"]]]],[11,"write_u128","","",3,[[["u128"]]]],[11,"write_uint","","",3,[[["usize"],["u64"]]]],[11,"write_uint128","","",3,[[["usize"],["u128"]]]],[11,"read_u16_into","","",3,[[]]],[11,"read_u32_into","","",3,[[]]],[11,"read_u64_into","","",3,[[]]],[11,"read_u128_into","","",3,[[]]],[11,"write_u16_into","","",3,[[]]],[11,"write_u32_into","","",3,[[]]],[11,"write_u64_into","","",3,[[]]],[11,"write_u128_into","","",3,[[]]],[11,"from_slice_u16","","",3,[[]]],[11,"from_slice_u32","","",3,[[]]],[11,"from_slice_u64","","",3,[[]]],[11,"from_slice_u128","","",3,[[]]],[11,"from_slice_f32","","",3,[[]]],[11,"from_slice_f64","","",3,[[]]],[11,"read_u16","","",4,[[],["u16"]]],[11,"read_u32","","",4,[[],["u32"]]],[11,"read_u64","","",4,[[],["u64"]]],[11,"read_u128","","",4,[[],["u128"]]],[11,"read_uint","","",4,[[["usize"]],["u64"]]],[11,"read_uint128","","",4,[[["usize"]],["u128"]]],[11,"write_u16","","",4,[[["u16"]]]],[11,"write_u32","","",4,[[["u32"]]]],[11,"write_u64","","",4,[[["u64"]]]],[11,"write_u128","","",4,[[["u128"]]]],[11,"write_uint","","",4,[[["usize"],["u64"]]]],[11,"write_uint128","","",4,[[["usize"],["u128"]]]],[11,"read_u16_into","","",4,[[]]],[11,"read_u32_into","","",4,[[]]],[11,"read_u64_into","","",4,[[]]],[11,"read_u128_into","","",4,[[]]],[11,"write_u16_into","","",4,[[]]],[11,"write_u32_into","","",4,[[]]],[11,"write_u64_into","","",4,[[]]],[11,"write_u128_into","","",4,[[]]],[11,"from_slice_u16","","",4,[[]]],[11,"from_slice_u32","","",4,[[]]],[11,"from_slice_u64","","",4,[[]]],[11,"from_slice_u128","","",4,[[]]],[11,"from_slice_f32","","",4,[[]]],[11,"from_slice_f64","","",4,[[]]],[11,"clone","","",3,[[["self"]],["bigendian"]]],[11,"clone","","",4,[[["self"]],["littleendian"]]],[11,"default","","",3,[[],["bigendian"]]],[11,"default","","",4,[[],["littleendian"]]],[11,"cmp","","",3,[[["bigendian"],["self"]],["ordering"]]],[11,"cmp","","",4,[[["self"],["littleendian"]],["ordering"]]],[11,"eq","","",3,[[["bigendian"],["self"]],["bool"]]],[11,"eq","","",4,[[["self"],["littleendian"]],["bool"]]],[11,"partial_cmp","","",3,[[["bigendian"],["self"]],[["option",["ordering"]],["ordering"]]]],[11,"partial_cmp","","",4,[[["self"],["littleendian"]],[["option",["ordering"]],["ordering"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"hash","","",3,[[["self"],["__h"]]]],[11,"hash","","",4,[[["self"],["__h"]]]],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,[[["self"]],[["result",["u8"]],["u8"]]]],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,[[["self"]],[["i8"],["result",["i8"]]]]],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,[[["self"]],[["u16"],["result",["u16"]]]]],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,[[["self"]],[["result",["i16"]],["i16"]]]],[11,"read_u24","","Reads an unsigned 24 bit integer from the underlying reader.",0,[[["self"]],[["result",["u32"]],["u32"]]]],[11,"read_i24","","Reads a signed 24 bit integer from the underlying reader.",0,[[["self"]],[["i32"],["result",["i32"]]]]],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,[[["self"]],[["result",["u32"]],["u32"]]]],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,[[["self"]],[["i32"],["result",["i32"]]]]],[11,"read_u48","","Reads an unsigned 48 bit integer from the underlying reader.",0,[[["self"]],[["u64"],["result",["u64"]]]]],[11,"read_i48","","Reads a signed 48 bit integer from the underlying reader.",0,[[["self"]],[["i64"],["result",["i64"]]]]],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,[[["self"]],[["u64"],["result",["u64"]]]]],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,[[["self"]],[["i64"],["result",["i64"]]]]],[11,"read_u128","","Reads an unsigned 128 bit integer from the underlying…",0,[[["self"]],[["u128"],["result",["u128"]]]]],[11,"read_i128","","Reads a signed 128 bit integer from the underlying reader.",0,[[["self"]],[["i128"],["result",["i128"]]]]],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying…",0,[[["self"],["usize"]],[["u64"],["result",["u64"]]]]],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,[[["self"],["usize"]],[["i64"],["result",["i64"]]]]],[11,"read_uint128","","Reads an unsigned n-bytes integer from the underlying…",0,[[["self"],["usize"]],[["u128"],["result",["u128"]]]]],[11,"read_int128","","Reads a signed n-bytes integer from the underlying reader.",0,[[["self"],["usize"]],[["i128"],["result",["i128"]]]]],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point…",0,[[["self"]],[["f32"],["result",["f32"]]]]],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point…",0,[[["self"]],[["result",["f64"]],["f64"]]]],[11,"read_u16_into","","Reads a sequence of unsigned 16 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_u32_into","","Reads a sequence of unsigned 32 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_u64_into","","Reads a sequence of unsigned 64 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_u128_into","","Reads a sequence of unsigned 128 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i8_into","","Reads a sequence of signed 8 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i16_into","","Reads a sequence of signed 16 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i32_into","","Reads a sequence of signed 32 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i64_into","","Reads a sequence of signed 64 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_i128_into","","Reads a sequence of signed 128 bit integers from the…",0,[[["self"]],["result"]]],[11,"read_f32_into","","Reads a sequence of IEEE754 single-precision (4 bytes)…",0,[[["self"]],["result"]]],[11,"read_f32_into_unchecked","","DEPRECATED.",0,[[["self"]],["result"]]],[11,"read_f64_into","","Reads a sequence of IEEE754 double-precision (8 bytes)…",0,[[["self"]],["result"]]],[11,"read_f64_into_unchecked","","DEPRECATED.",0,[[["self"]],["result"]]],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,[[["self"],["u8"]],["result"]]],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,[[["self"],["i8"]],["result"]]],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,[[["u16"],["self"]],["result"]]],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,[[["self"],["i16"]],["result"]]],[11,"write_u24","","Writes an unsigned 24 bit integer to the underlying writer.",1,[[["self"],["u32"]],["result"]]],[11,"write_i24","","Writes a signed 24 bit integer to the underlying writer.",1,[[["self"],["i32"]],["result"]]],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,[[["self"],["u32"]],["result"]]],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,[[["self"],["i32"]],["result"]]],[11,"write_u48","","Writes an unsigned 48 bit integer to the underlying writer.",1,[[["self"],["u64"]],["result"]]],[11,"write_i48","","Writes a signed 48 bit integer to the underlying writer.",1,[[["i64"],["self"]],["result"]]],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,[[["self"],["u64"]],["result"]]],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,[[["i64"],["self"]],["result"]]],[11,"write_u128","","Writes an unsigned 128 bit integer to the underlying writer.",1,[[["self"],["u128"]],["result"]]],[11,"write_i128","","Writes a signed 128 bit integer to the underlying writer.",1,[[["self"],["i128"]],["result"]]],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,[[["self"],["u64"],["usize"]],["result"]]],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,[[["i64"],["self"],["usize"]],["result"]]],[11,"write_uint128","","Writes an unsigned n-bytes integer to the underlying writer.",1,[[["self"],["usize"],["u128"]],["result"]]],[11,"write_int128","","Writes a signed n-bytes integer to the underlying writer.",1,[[["self"],["i128"],["usize"]],["result"]]],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point…",1,[[["f32"],["self"]],["result"]]],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point…",1,[[["self"],["f64"]],["result"]]]],"p":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["enum_primitive"] = {"doc":"This crate exports a macro `enum_from_primitive!` that…","i":[[4,"Option","enum_primitive","The `Option` type. See the module level documentation for…",null,null],[13,"None","","No value",0,null],[13,"Some","","Some value `T`",0,null],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",1,[[["isize"]],["option"]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",1,[[["i8"]],["option"]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",1,[[["i16"]],["option"]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",1,[[["i32"]],["option"]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",1,[[["i64"]],["option"]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",1,[[["i128"]],["option"]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",1,[[["usize"]],["option"]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",1,[[["u8"]],["option"]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",1,[[["u16"]],["option"]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",1,[[["u32"]],["option"]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",1,[[["u64"]],["option"]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",1,[[["u128"]],["option"]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",1,[[["f32"]],["option"]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",1,[[["f64"]],["option"]]],[14,"enum_from_primitive_impl_ty","","Helper macro for internal use by `enum_from_primitive!`.",null,null],[14,"enum_from_primitive_impl","","Helper macro for internal use by `enum_from_primitive!`.",null,null],[14,"enum_from_primitive","","Wrap this macro around an `enum` declaration to get an…",null,null],[11,"from","","",0,[[["t"]],["t"]]],[11,"from","","",0,[[],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"into_iter","","",0,[[],["i"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"hash","","",0,[[["self"],["__h"]]]],[11,"from","","",0,[[["t"]],["option"]]],[11,"from","","",0,[[["option"]],[["option"],["t"]]]],[11,"from","","",0,[[["option"]],[["option"],["t"]]]],[11,"into_result","","",0,[[],[["noneerror"],["result",["noneerror"]]]]],[11,"from_ok","","",0,[[["t"]],["option"]]],[11,"from_error","","",0,[[["noneerror"]],["option"]]],[11,"from_iter","","Takes each element in the [`Iterator`]: if it is…",0,[[["i"]],["option"]]],[11,"eq","","",0,[[["self"],["option"]],["bool"]]],[11,"ne","","",0,[[["self"],["option"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],[["error"],["result",["error"]]]]],[11,"clone","","",0,[[["self"]],["option"]]],[11,"clone_from","","",0,[[["self"],["option"]]]],[11,"sum","","Takes each element in the `Iterator`: if it is a `None`,…",0,[[["i"]],["option"]]],[11,"cmp","","",0,[[["self"],["option"]],["ordering"]]],[11,"into_iter","","Returns a consuming iterator over the possibly contained…",0,[[],["intoiter"]]],[11,"product","","Takes each element in the `Iterator`: if it is a `None`,…",0,[[["i"]],["option"]]],[11,"partial_cmp","","",0,[[["self"],["option"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",0,[[["self"],["option"]],["bool"]]],[11,"le","","",0,[[["self"],["option"]],["bool"]]],[11,"gt","","",0,[[["self"],["option"]],["bool"]]],[11,"ge","","",0,[[["self"],["option"]],["bool"]]],[11,"default","","Returns [`None`][Option::None].",0,[[],["option"]]],[11,"is_some","","Returns `true` if the option is a [`Some`] value.",0,[[["self"]],["bool"]]],[11,"is_none","","Returns `true` if the option is a [`None`] value.",0,[[["self"]],["bool"]]],[11,"contains","","Returns `true` if the option is a [`Some`] value…",0,[[["self"],["u"]],["bool"]]],[11,"as_ref","","Converts from `&Option<T>` to `Option<&T>`.",0,[[["self"]],[["option"],["t"]]]],[11,"as_mut","","Converts from `&mut Option<T>` to `Option<&mut T>`.",0,[[["self"]],[["option"],["t"]]]],[11,"as_pin_ref","","Converts from [`Pin`]`<&Option<T>>` to…",0,[[["pin",["option"]],["option"]],[["option",["pin"]],["pin"]]]],[11,"as_pin_mut","","Converts from [`Pin`]`<&mut Option<T>>` to…",0,[[["option"],["pin",["option"]]],[["pin"],["option",["pin"]]]]],[11,"expect","","Unwraps an option, yielding the content of a [`Some`].",0,[[["str"]],["t"]]],[11,"unwrap","","Moves the value `v` out of the `Option<T>` if it is…",0,[[],["t"]]],[11,"unwrap_or","","Returns the contained value or a default.",0,[[["t"]],["t"]]],[11,"unwrap_or_else","","Returns the contained value or computes it from a closure.",0,[[["f"]],["t"]]],[11,"map","","Maps an `Option<T>` to `Option<U>` by applying a function…",0,[[["f"]],["option"]]],[11,"map_or","","Applies a function to the contained value (if any), or…",0,[[["u"],["f"]],["u"]]],[11,"map_or_else","","Applies a function to the contained value (if any), or…",0,[[["d"],["f"]],["u"]]],[11,"ok_or","","Transforms the `Option<T>` into a [`Result<T, E>`],…",0,[[["e"]],["result"]]],[11,"ok_or_else","","Transforms the `Option<T>` into a [`Result<T, E>`],…",0,[[["f"]],["result"]]],[11,"iter","","Returns an iterator over the possibly contained value.",0,[[["self"]],["iter"]]],[11,"iter_mut","","Returns a mutable iterator over the possibly contained…",0,[[["self"]],["itermut"]]],[11,"and","","Returns [`None`] if the option is [`None`], otherwise…",0,[[["option"]],["option"]]],[11,"and_then","","Returns [`None`] if the option is [`None`], otherwise…",0,[[["f"]],["option"]]],[11,"filter","","Returns [`None`] if the option is [`None`], otherwise…",0,[[["p"]],["option"]]],[11,"or","","Returns the option if it contains a value, otherwise…",0,[[["option"]],["option"]]],[11,"or_else","","Returns the option if it contains a value, otherwise calls…",0,[[["f"]],["option"]]],[11,"xor","","Returns [`Some`] if exactly one of `self`, `optb` is…",0,[[["option"]],["option"]]],[11,"get_or_insert","","Inserts `v` into the option if it is [`None`], then…",0,[[["self"],["t"]],["t"]]],[11,"get_or_insert_with","","Inserts a value computed from `f` into the option if it is…",0,[[["self"],["f"]],["t"]]],[11,"take","","Takes the value out of the option, leaving a [`None`] in…",0,[[["self"]],["option"]]],[11,"replace","","Replaces the actual value in the option by the value given…",0,[[["self"],["t"]],["option"]]],[11,"copied","","Maps an `Option<&T>` to an `Option<T>` by copying the…",0,[[],["option"]]],[11,"copied","","Maps an `Option<&mut T>` to an `Option<T>` by copying the…",0,[[],["option"]]],[11,"cloned","","Maps an `Option<&T>` to an `Option<T>` by cloning the…",0,[[],["option"]]],[11,"cloned","","Maps an `Option<&mut T>` to an `Option<T>` by cloning the…",0,[[],["option"]]],[11,"expect_none","","Unwraps an option, expecting [`None`] and returning nothing.",0,[[["str"]]]],[11,"unwrap_none","","Unwraps an option, expecting [`None`] and returning nothing.",0,[[]]],[11,"unwrap_or_default","","Returns the contained value or a default",0,[[],["t"]]],[11,"as_deref","","Converts from `Option<T>` (or `&Option<T>`) to…",0,[[["self"]],["option"]]],[11,"as_deref_mut","","Converts from `Option<T>` (or `&mut Option<T>`) to…",0,[[["self"]],["option"]]],[11,"transpose","","Transposes an `Option` of a [`Result`] into a [`Result`]…",0,[[],[["result",["option"]],["option"]]]],[11,"flatten","","Converts from `Option<Option<T>>` to `Option<T>`",0,[[],["option"]]]],"p":[[4,"Option"],[8,"FromPrimitive"]]};
searchIndex["modbus"] = {"doc":"Modbus implementation in pure Rust.","i":[[4,"ExceptionCode","modbus","Modbus exception codes returned from the server.",null,null],[13,"IllegalFunction","","",0,null],[13,"IllegalDataAddress","","",0,null],[13,"IllegalDataValue","","",0,null],[13,"SlaveOrServerFailure","","",0,null],[13,"Acknowledge","","",0,null],[13,"SlaveOrServerBusy","","",0,null],[13,"NegativeAcknowledge","","",0,null],[13,"MemoryParity","","",0,null],[13,"NotDefined","","",0,null],[13,"GatewayPath","","",0,null],[13,"GatewayTarget","","",0,null],[4,"Reason","","`InvalidData` reasons",null,null],[13,"UnexpectedReplySize","","",1,null],[13,"BytecountNotEven","","",1,null],[13,"SendBufferEmpty","","",1,null],[13,"RecvBufferEmpty","","",1,null],[13,"SendBufferTooBig","","",1,null],[13,"DecodingError","","",1,null],[13,"EncodingError","","",1,null],[13,"InvalidByteorder","","",1,null],[13,"Custom","","",1,null],[4,"Error","","Combination of Modbus, IO and data corruption errors",null,null],[13,"Exception","","",2,null],[13,"Io","","",2,null],[13,"InvalidResponse","","",2,null],[13,"InvalidData","","",2,null],[13,"InvalidFunction","","",2,null],[13,"ParseCoilError","","",2,null],[4,"Coil","","Single bit status values, used in read or write coil…",null,null],[13,"On","","",3,null],[13,"Off","","",3,null],[0,"binary","","",null,null],[5,"unpack_bits","modbus::binary","",null,[[["u16"]],[["vec",["coil"]],["coil"]]]],[5,"pack_bits","","",null,[[],[["vec",["u8"]],["u8"]]]],[5,"unpack_bytes","","",null,[[],[["vec",["u8"]],["u8"]]]],[5,"pack_bytes","","",null,[[],[["result",["vec"]],["vec",["u16"]]]]],[0,"scoped","modbus","A set of objects which automatically change their register…",null,null],[3,"ScopedCoil","modbus::scoped","Auto object which modifies it's coil value depending on a…",null,null],[3,"ScopedRegister","","Auto object which modifies it's register value depending…",null,null],[4,"CoilDropFunction","","Action to perform when the `ScopedCoil` is dropped.",null,null],[13,"On","","Set the coil to `Coil::On`",4,null],[13,"Off","","Set the coil to `Coil::Off`",4,null],[13,"Toggle","","Toggle the current value.",4,null],[4,"RegisterDropFunction","","Action to perform when the `ScopedRegister` is dropped.",null,null],[13,"Zero","","Set the register to zero value",5,null],[13,"Increment","","Increment the current register value by 1",5,null],[13,"Decrement","","Decrement the current register value by 1",5,null],[13,"Value","","Set the register value to the given value.",5,null],[13,"Fun","","Execute the given function on the current value, setting…",5,null],[11,"new","","Create a new `ScopedCoil` object with `address` and drop…",6,[[["u16"],["coildropfunction"],["transport"]],[["scopedcoil"],["result",["scopedcoil"]]]]],[11,"mut_transport","","",6,[[["self"]],["transport"]]],[11,"new","","Create a new `ScopedRegister` object with `address` and…",7,[[["u16"],["transport"],["registerdropfunction"]],[["result",["scopedregister"]],["scopedregister"]]]],[11,"mut_transport","","",7,[[["self"]],["transport"]]],[0,"tcp","modbus","The Modbus TCP backend implements a Modbus variant used…",null,null],[3,"Config","modbus::tcp","Config structure for more control over the tcp socket…",null,null],[12,"tcp_port","","The TCP port to use for communication (Default: `502`)",8,null],[12,"tcp_connect_timeout","","Connection timeout for TCP socket (Default: `OS Default`)",8,null],[12,"tcp_read_timeout","","Timeout when reading from the TCP socket (Default:…",8,null],[12,"tcp_write_timeout","","Timeout when writing to the TCP socket (Default: `infinite`)",8,null],[12,"modbus_uid","","The modbus Unit Identifier used in the modbus layer…",8,null],[3,"Transport","","Context object which holds state for all modbus operations.",null,null],[11,"new","","Create a new context context object and connect it to…",9,[[["str"]],[["result",["transport"]],["transport"]]]],[11,"new_with_cfg","","Create a new context object and connect it to `addr` on…",9,[[["str"],["config"]],[["result",["transport"]],["transport"]]]],[11,"close","","",9,[[["self"]],["result"]]],[6,"Result","modbus","Result type used to nofify success or failure in…",null,null],[8,"Client","","",null,null],[10,"read_discrete_inputs","","",10,[[["u16"],["self"]],[["vec",["coil"]],["result",["vec"]]]]],[10,"read_coils","","",10,[[["u16"],["self"]],[["vec",["coil"]],["result",["vec"]]]]],[10,"write_single_coil","","",10,[[["u16"],["self"],["coil"]],["result"]]],[10,"write_multiple_coils","","",10,[[["u16"],["self"]],["result"]]],[10,"read_input_registers","","",10,[[["u16"],["self"]],[["result",["vec"]],["vec",["u16"]]]]],[10,"read_holding_registers","","",10,[[["u16"],["self"]],[["result",["vec"]],["vec",["u16"]]]]],[10,"write_single_register","","",10,[[["u16"],["self"]],["result"]]],[10,"write_multiple_registers","","",10,[[["u16"],["self"]],["result"]]],[10,"set_uid","","",10,[[["self"],["u8"]]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"from","modbus::scoped","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"from","modbus::tcp","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,[[["self"],["t"]]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"read_coils","","Read `count` bits starting at address `addr`.",9,[[["u16"],["self"]],[["vec",["coil"]],["result",["vec"]]]]],[11,"read_discrete_inputs","","Read `count` input bits starting at address `addr`.",9,[[["u16"],["self"]],[["vec",["coil"]],["result",["vec"]]]]],[11,"read_holding_registers","","Read `count` 16bit registers starting at address `addr`.",9,[[["u16"],["self"]],[["result",["vec"]],["vec",["u16"]]]]],[11,"read_input_registers","","Read `count` 16bit input registers starting at address…",9,[[["u16"],["self"]],[["result",["vec"]],["vec",["u16"]]]]],[11,"write_single_coil","","Write a single coil (bit) to address `addr`.",9,[[["u16"],["self"],["coil"]],["result"]]],[11,"write_single_register","","Write a single 16bit register to address `addr`.",9,[[["u16"],["self"]],["result"]]],[11,"write_multiple_coils","","Write a multiple coils (bits) starting at address `addr`.",9,[[["u16"],["self"]],["result"]]],[11,"write_multiple_registers","","Write a multiple 16bit registers starting at address `addr`.",9,[[["u16"],["self"]],["result"]]],[11,"set_uid","","Set the unit identifier.",9,[[["self"],["u8"]]]],[11,"drop","modbus::scoped","",6,[[["self"]]]],[11,"drop","","",7,[[["self"]]]],[11,"from","modbus","",2,[[["exceptioncode"]],["error"]]],[11,"from","","",2,[[["error"]],["error"]]],[11,"from","","",3,[[["bool"]],["coil"]]],[11,"clone","modbus::tcp","",8,[[["self"]],["config"]]],[11,"clone","modbus","",3,[[["self"]],["coil"]]],[11,"default","modbus::tcp","",8,[[],["config"]]],[11,"eq","modbus","",0,[[["exceptioncode"],["self"]],["bool"]]],[11,"eq","","",3,[[["self"],["coil"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"from_str","","",3,[[["str"]],[["coil"],["result",["coil"]]]]],[11,"not","","",3,[[],["coil"]]],[11,"description","","",2,[[["self"]],["str"]]],[11,"cause","","",2,[[["self"]],[["option",["error"]],["error"]]]],[11,"from_i64","","",0,[[["i64"]],["option"]]],[11,"from_u64","","",0,[[["u64"]],["option"]]]],"p":[[4,"ExceptionCode"],[4,"Reason"],[4,"Error"],[4,"Coil"],[4,"CoilDropFunction"],[4,"RegisterDropFunction"],[3,"ScopedCoil"],[3,"ScopedRegister"],[3,"Config"],[3,"Transport"],[8,"Client"]]};
searchIndex["num_traits"] = {"doc":"Numeric traits for generic mathematics","i":[[8,"Bounded","num_traits","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",0,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",0,[[],["self"]]],[8,"Float","","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",1,[[],["self"]]],[10,"infinity","","Returns the infinite value.",1,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",1,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",1,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",1,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",1,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",1,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",1,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",1,[[],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or…",1,[[],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",1,[[],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,…",1,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",1,[[],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",1,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",1,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",1,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",1,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",1,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",1,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",1,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",1,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",1,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",1,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",1,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",1,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",1,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",1,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",1,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",1,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",1,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",1,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",1,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",1,[[],["self"]]],[11,"to_degrees","","Converts radians to degrees.",1,[[],["self"]]],[11,"to_radians","","Converts degrees to radians.",1,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",1,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",1,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",1,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",1,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",1,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",1,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",1,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",1,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",1,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",1,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",1,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",1,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",1,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",1,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",1,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",1,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",1,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",1,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",1,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",1,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",1,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",1,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",2,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",2,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",2,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",2,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",2,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",2,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",2,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",2,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",2,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",2,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",2,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",2,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",2,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",2,[[],["self"]]],[10,"PI","","Return Archimedes’ constant `π`.",2,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",2,[[],["self"]]],[11,"TAU","","Return the full circle constant `τ`.",2,[[],["self"]]],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",3,[[],["self"]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",3,[[["self"]]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",3,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",4,[[],["self"]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",4,[[["self"]]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",4,[[["self"]],["bool"]]],[5,"zero","","Returns the additive identity, `0`.",null,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["t"]]],[8,"CheckedAdd","","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",5,[[["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",6,[[["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",7,[[["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",8,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",9,[[["u32"],["self"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",10,[[["u32"],["self"]],["option"]]],[8,"WrappingAdd","","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",11,[[["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",12,[[["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",13,[[["self"]],["self"]]],[8,"Saturating","","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",14,[[],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",14,[[],["self"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",15,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",15,[[["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",15,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",15,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",15,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[5,"abs","","Computes the absolute value.",null,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",null,[[["t"]],["t"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",16,[[],["t"]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",17,[[["isize"]],["option"]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",17,[[["i8"]],["option"]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",17,[[["i16"]],["option"]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",17,[[["i32"]],["option"]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",17,[[["i64"]],["option"]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",17,[[["i128"]],["option"]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",17,[[["usize"]],["option"]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",17,[[["u8"]],["option"]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",17,[[["u16"]],["option"]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",17,[[["u32"]],["option"]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",17,[[["u64"]],["option"]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",17,[[["u128"]],["option"]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",17,[[["f32"]],["option"]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",17,[[["f64"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`. If the value…",18,[[["self"]],[["isize"],["option",["isize"]]]]],[11,"to_i8","","Converts the value of `self` to an `i8`. If the value…",18,[[["self"]],[["option",["i8"]],["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`. If the value…",18,[[["self"]],[["option",["i16"]],["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`. If the value…",18,[[["self"]],[["option",["i32"]],["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`. If the value…",18,[[["self"]],[["i64"],["option",["i64"]]]]],[11,"to_i128","","Converts the value of `self` to an `i128`. If the value…",18,[[["self"]],[["option",["i128"]],["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`. If the value…",18,[[["self"]],[["option",["usize"]],["usize"]]]],[11,"to_u8","","Converts the value of `self` to a `u8`. If the value…",18,[[["self"]],[["u8"],["option",["u8"]]]]],[11,"to_u16","","Converts the value of `self` to a `u16`. If the value…",18,[[["self"]],[["u16"],["option",["u16"]]]]],[11,"to_u32","","Converts the value of `self` to a `u32`. If the value…",18,[[["self"]],[["u32"],["option",["u32"]]]]],[10,"to_u64","","Converts the value of `self` to a `u64`. If the value…",18,[[["self"]],[["option",["u64"]],["u64"]]]],[11,"to_u128","","Converts the value of `self` to a `u128`. If the value…",18,[[["self"]],[["u128"],["option",["u128"]]]]],[11,"to_f32","","Converts the value of `self` to an `f32`. If the value…",18,[[["self"]],[["f32"],["option",["f32"]]]]],[11,"to_f64","","Converts the value of `self` to an `f64`. If the value…",18,[[["self"]],[["f64"],["option",["f64"]]]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",19,[[["t"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",null,[[["t"]],["option"]]],[8,"PrimInt","","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",20,[[],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",20,[[],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",20,[[],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",20,[[],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",20,[[],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",20,[[],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",20,[[],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",20,[[],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",20,[[],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",20,[[["u32"]],["self"]]],[5,"pow","","Raises a value to the power of exp, using exponentiation…",null,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["t"],["usize"]],["option"]]],[8,"Num","","The base trait for numeric types, covering `0` and `1`…",null,null],[16,"FromStrRadixErr","","",21,null],[10,"from_str_radix","","Convert from a string and radix <= 36.",21,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",null,null],[8,"NumRef","","The trait for `Num` types which also implement numeric…",null,null],[8,"RefNum","","The trait for references which implement numeric…",null,null],[8,"NumAssignOps","","The trait for types implementing numeric assignment…",null,null],[8,"NumAssign","","The trait for `Num` types which also implement assignment…",null,null],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement…",null,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",22,null],[13,"Invalid","","",22,null],[3,"ParseFloatError","","",null,null],[12,"kind","","",23,null],[5,"clamp","","A value bounded by a minimum and a maximum",null,[[["t"]],["t"]]],[0,"identities","","",null,null],[8,"Zero","num_traits::identities","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",3,[[],["self"]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",3,[[["self"]]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",3,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",4,[[],["self"]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",4,[[["self"]]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",4,[[["self"]],["bool"]]],[5,"zero","","Returns the additive identity, `0`.",null,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["t"]]],[0,"sign","num_traits","",null,null],[8,"Signed","num_traits::sign","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",15,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",15,[[["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",15,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",15,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",15,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[5,"abs","","Computes the absolute value.",null,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",null,[[["t"]],["t"]]],[0,"ops","num_traits","",null,null],[0,"saturating","num_traits::ops","",null,null],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",14,[[],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",14,[[],["self"]]],[0,"checked","num_traits::ops","",null,null],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",5,[[["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",6,[[["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",7,[[["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",8,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",9,[[["u32"],["self"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",10,[[["u32"],["self"]],["option"]]],[0,"wrapping","num_traits::ops","",null,null],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",11,[[["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",12,[[["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",13,[[["self"]],["self"]]],[0,"bounds","num_traits","",null,null],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",0,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",0,[[],["self"]]],[0,"float","num_traits","",null,null],[8,"Float","num_traits::float","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",1,[[],["self"]]],[10,"infinity","","Returns the infinite value.",1,[[],["self"]]],[10,"neg_infinity","","Returns the negative infinite value.",1,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",1,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",1,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",1,[[],["self"]]],[11,"epsilon","","Returns epsilon, a small positive value.",1,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",1,[[],["self"]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",1,[[],["bool"]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or…",1,[[],["bool"]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",1,[[],["bool"]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,…",1,[[],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",1,[[],["fpcategory"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",1,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",1,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",1,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",1,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",1,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",1,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",1,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",1,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",1,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",1,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",1,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",1,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a floating point power.",1,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",1,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",1,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",1,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",1,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",1,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",1,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",1,[[],["self"]]],[11,"to_degrees","","Converts radians to degrees.",1,[[],["self"]]],[11,"to_radians","","Converts degrees to radians.",1,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",1,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",1,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",1,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",1,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",1,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",1,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",1,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",1,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",1,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",1,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",1,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",1,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",1,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",1,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",1,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",1,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",1,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",1,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",1,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",1,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",1,[[],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",1,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",2,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",2,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",2,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",2,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",2,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",2,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",2,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",2,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",2,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",2,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",2,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",2,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",2,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",2,[[],["self"]]],[10,"PI","","Return Archimedes’ constant `π`.",2,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",2,[[],["self"]]],[11,"TAU","","Return the full circle constant `τ`.",2,[[],["self"]]],[0,"real","num_traits","",null,null],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have…",null,null],[10,"min_value","","Returns the smallest finite value that this type can…",24,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",24,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",24,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",24,[[],["self"]]],[10,"floor","","Returns the largest integer less than or equal to a number.",24,[[],["self"]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",24,[[],["self"]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",24,[[],["self"]]],[10,"trunc","","Return the integer part of a number.",24,[[],["self"]]],[10,"fract","","Returns the fractional part of a number.",24,[[],["self"]]],[10,"abs","","Computes the absolute value of `self`. Returns…",24,[[],["self"]]],[10,"signum","","Returns a number that represents the sign of `self`.",24,[[],["self"]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",24,[[],["bool"]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",24,[[],["bool"]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",24,[[],["self"]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",24,[[],["self"]]],[10,"powi","","Raise a number to an integer power.",24,[[["i32"]],["self"]]],[10,"powf","","Raise a number to a real number power.",24,[[],["self"]]],[10,"sqrt","","Take the square root of a number.",24,[[],["self"]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",24,[[],["self"]]],[10,"exp2","","Returns `2^(self)`.",24,[[],["self"]]],[10,"ln","","Returns the natural logarithm of the number.",24,[[],["self"]]],[10,"log","","Returns the logarithm of the number with respect to an…",24,[[],["self"]]],[10,"log2","","Returns the base 2 logarithm of the number.",24,[[],["self"]]],[10,"log10","","Returns the base 10 logarithm of the number.",24,[[],["self"]]],[10,"to_degrees","","Converts radians to degrees.",24,[[],["self"]]],[10,"to_radians","","Converts degrees to radians.",24,[[],["self"]]],[10,"max","","Returns the maximum of the two numbers.",24,[[],["self"]]],[10,"min","","Returns the minimum of the two numbers.",24,[[],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",24,[[],["self"]]],[10,"cbrt","","Take the cubic root of a number.",24,[[],["self"]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",24,[[],["self"]]],[10,"sin","","Computes the sine of a number (in radians).",24,[[],["self"]]],[10,"cos","","Computes the cosine of a number (in radians).",24,[[],["self"]]],[10,"tan","","Computes the tangent of a number (in radians).",24,[[],["self"]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",24,[[],["self"]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",24,[[],["self"]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",24,[[],["self"]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",24,[[],["self"]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",24,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",24,[[],["self"]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",24,[[],["self"]]],[10,"sinh","","Hyperbolic sine function.",24,[[],["self"]]],[10,"cosh","","Hyperbolic cosine function.",24,[[],["self"]]],[10,"tanh","","Hyperbolic tangent function.",24,[[],["self"]]],[10,"asinh","","Inverse hyperbolic sine function.",24,[[],["self"]]],[10,"acosh","","Inverse hyperbolic cosine function.",24,[[],["self"]]],[10,"atanh","","Inverse hyperbolic tangent function.",24,[[],["self"]]],[0,"cast","num_traits","",null,null],[8,"AsPrimitive","num_traits::cast","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",16,[[],["t"]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",17,[[["isize"]],["option"]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",17,[[["i8"]],["option"]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",17,[[["i16"]],["option"]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",17,[[["i32"]],["option"]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",17,[[["i64"]],["option"]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",17,[[["i128"]],["option"]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",17,[[["usize"]],["option"]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",17,[[["u8"]],["option"]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",17,[[["u16"]],["option"]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",17,[[["u32"]],["option"]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",17,[[["u64"]],["option"]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",17,[[["u128"]],["option"]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",17,[[["f32"]],["option"]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",17,[[["f64"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`. If the value…",18,[[["self"]],[["isize"],["option",["isize"]]]]],[11,"to_i8","","Converts the value of `self` to an `i8`. If the value…",18,[[["self"]],[["option",["i8"]],["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`. If the value…",18,[[["self"]],[["option",["i16"]],["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`. If the value…",18,[[["self"]],[["option",["i32"]],["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`. If the value…",18,[[["self"]],[["i64"],["option",["i64"]]]]],[11,"to_i128","","Converts the value of `self` to an `i128`. If the value…",18,[[["self"]],[["option",["i128"]],["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`. If the value…",18,[[["self"]],[["option",["usize"]],["usize"]]]],[11,"to_u8","","Converts the value of `self` to a `u8`. If the value…",18,[[["self"]],[["u8"],["option",["u8"]]]]],[11,"to_u16","","Converts the value of `self` to a `u16`. If the value…",18,[[["self"]],[["u16"],["option",["u16"]]]]],[11,"to_u32","","Converts the value of `self` to a `u32`. If the value…",18,[[["self"]],[["u32"],["option",["u32"]]]]],[10,"to_u64","","Converts the value of `self` to a `u64`. If the value…",18,[[["self"]],[["option",["u64"]],["u64"]]]],[11,"to_u128","","Converts the value of `self` to a `u128`. If the value…",18,[[["self"]],[["u128"],["option",["u128"]]]]],[11,"to_f32","","Converts the value of `self` to an `f32`. If the value…",18,[[["self"]],[["f32"],["option",["f32"]]]]],[11,"to_f64","","Converts the value of `self` to an `f64`. If the value…",18,[[["self"]],[["f64"],["option",["f64"]]]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",19,[[["t"]],["option"]]],[5,"cast","","Cast from one machine scalar to another.",null,[[["t"]],["option"]]],[0,"int","num_traits","",null,null],[8,"PrimInt","num_traits::int","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",20,[[],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",20,[[],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",20,[[],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",20,[[],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount,…",20,[[["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",20,[[],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",20,[[],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",20,[[],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",20,[[],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",20,[[],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",20,[[["u32"]],["self"]]],[0,"pow","num_traits","",null,null],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation…",null,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["t"],["usize"]],["option"]]],[11,"from","num_traits","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"to_string","","",23,[[["self"]],["string"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"fmt","","",23,[[["self"],["formatter"]],[["error"],["result",["error"]]]]],[11,"fmt","","",22,[[["self"],["formatter"]],[["error"],["result",["error"]]]]],[11,"fmt","","",23,[[["self"],["formatter"]],[["error"],["result",["error"]]]]]],"p":[[8,"Bounded"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"WrappingAdd"],[8,"WrappingMul"],[8,"WrappingSub"],[8,"Saturating"],[8,"Signed"],[8,"AsPrimitive"],[8,"FromPrimitive"],[8,"ToPrimitive"],[8,"NumCast"],[8,"PrimInt"],[8,"Num"],[4,"FloatErrorKind"],[3,"ParseFloatError"],[8,"Real"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);